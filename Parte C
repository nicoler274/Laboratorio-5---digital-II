//******************************************/
// Universidad del Valle de Guatemala
// BE3029 - Electronica Digital 2
// Nicole Rodriguez
// 21/07/2025
// Laboratorio 5
// MCU: ESP32 dev kit 1.0
//******************************************/
//******************************************/
// Librerías
//******************************************/
#include <Arduino.h>
#include <stdint.h>
#include <driver/ledc.h>

//******************************************/
// Definiciones
//******************************************/
// Pines LEDs
#define ledR 13
#define ledG 12
#define ledB 25

// Pines botones
#define butSelec     18 // Selección de modo/LED
#define butBri       5  // Ajuste de brillo en modos LED
#define butDerecha   19
#define butIzquierda 21

// Servo
#define servo_pin 14

// PWM LEDs
#define pwmChannelR 0
#define pwmChannelG 1
#define pwmChannelB 2

#define freqPWM_LED 5000
#define resPWM_LED 8

// PWM Servo
#define pwmChannelServo 3
#define freqPWM_Servo 50
#define resPWM_Servo 16

//******************************************/
// Variables globales
//******************************************/
// Estados de botones
volatile bool flagSelec = false;
volatile bool flagBri   = false;
volatile bool moverDerecha = false;
volatile bool moverIzquierda = false;

// Anti-rebote
volatile unsigned long ultimaInterrupcionSelec = 0;
volatile unsigned long ultimaInterrupcionBri   = 0;
volatile unsigned long ultimaInterrupcionDer   = 0;
volatile unsigned long ultimaInterrupcionIzq   = 0;
const unsigned long tiempoRebote = 200; // ms

// Modo actual (0=Rojo, 1=Verde, 2=Azul, 3=Servo)
uint8_t modoActual = 0;
bool modoServoActivo = false; // Bandera para controlar transiciones

// Brillo LEDs
uint8_t nivelBrillo[3] = {0, 0, 0};
const uint8_t brillo[] = {0, 85, 170, 255};
const uint8_t numBrillos = sizeof(brillo) / sizeof(brillo[0]);

// Servo posiciones (16 bits)
uint32_t posiciones[] = {
  1638, // 0.5 ms (posición 0 - extremo izquierdo)
  3277, // 1.0 ms (posición 1)
  4915, // 1.5 ms (posición 2 - centro)
  6553, // 2.0 ms (posición 3)
  8192  // 2.5 ms (posición 4 - extremo derecho)
};
uint8_t posicionActual = 2; // Centro (posición 2)
uint32_t pulsoServo = posiciones[2]; // Pulso actual

// Movimiento servo
uint8_t pasoServo = 50; // microsegundos por actualización
unsigned long ultimaActualizacionServo = 0;
uint8_t intervaloServo = 20; // ms

//******************************************/
// ISRs
//******************************************/
void IRAM_ATTR ISR_cambioModo() {
  unsigned long tiempo = millis();
  if (tiempo - ultimaInterrupcionSelec > tiempoRebote) {
    flagSelec = true;
    ultimaInterrupcionSelec = tiempo;
  }
}

void IRAM_ATTR ISR_cambioBrillo() {
  unsigned long tiempo = millis();
  if (tiempo - ultimaInterrupcionBri > tiempoRebote) {
    flagBri = true;
    ultimaInterrupcionBri = tiempo;
  }
}

void IRAM_ATTR ISR_Derecha() {
  unsigned long tiempo = millis();
  if (tiempo - ultimaInterrupcionDer > tiempoRebote) {
    moverDerecha = true;
    ultimaInterrupcionDer = tiempo;
  }
}

void IRAM_ATTR ISR_Izquierda() {
  unsigned long tiempo = millis();
  if (tiempo - ultimaInterrupcionIzq > tiempoRebote) {
    moverIzquierda = true;
    ultimaInterrupcionIzq = tiempo;
  }
}

//******************************************/
// Inicialización PWM
//******************************************/
void initPWM() {
  // LEDs
  ledcSetup(pwmChannelR, freqPWM_LED, resPWM_LED);
  ledcAttachPin(ledR, pwmChannelR);
  ledcWrite(pwmChannelR, 0);

  ledcSetup(pwmChannelG, freqPWM_LED, resPWM_LED);
  ledcAttachPin(ledG, pwmChannelG);
  ledcWrite(pwmChannelG, 0);

  ledcSetup(pwmChannelB, freqPWM_LED, resPWM_LED);
  ledcAttachPin(ledB, pwmChannelB);
  ledcWrite(pwmChannelB, 0);

  // Servo
  ledcSetup(pwmChannelServo, freqPWM_Servo, resPWM_Servo);
  ledcAttachPin(servo_pin, pwmChannelServo);
  ledcWrite(pwmChannelServo, posiciones[posicionActual]);
}

//******************************************/
// Actualizar LEDs según brillo guardado
//******************************************/
void actualizarLEDs() {
  ledcWrite(pwmChannelR, brillo[nivelBrillo[0]]);
  ledcWrite(pwmChannelG, brillo[nivelBrillo[1]]);
  ledcWrite(pwmChannelB, brillo[nivelBrillo[2]]);
}

//******************************************/
// Apagar todos los LEDs
//******************************************/
void apagarLEDs() {
  ledcWrite(pwmChannelR, 0);
  ledcWrite(pwmChannelG, 0);
  ledcWrite(pwmChannelB, 0);
}

//******************************************/
// Mover servo 
//******************************************/
void moverServoSuave(uint32_t objetivo) {
  if (millis() - ultimaActualizacionServo >= intervaloServo) {
    ultimaActualizacionServo = millis();
    if (pulsoServo < objetivo) {
      pulsoServo += pasoServo;
      if (pulsoServo > objetivo) pulsoServo = objetivo;
    } else if (pulsoServo > objetivo) {
      pulsoServo -= pasoServo;
    } ledcWrite(pwmChannelServo, pulsoServo);
  }
}

//******************************************/
// Actualizar indicación LED en modo Servo
//******************************************/
void actualizarIndicacionServo() {
  // Primero apagamos todos los LEDs
  apagarLEDs();
  // Luego encendemos solo el LED correspondiente a la posición actual
  switch(posicionActual) {
    case 0: // Extremo izquierdo - todos apagados
      apagarLEDs();
      break;
    case 1: // Posición 1 - solo LED Rojo
      ledcWrite(pwmChannelR, 255);
      ledcWrite(pwmChannelG, 0);
      ledcWrite(pwmChannelB, 0);
      break;
    case 2: // Centro - solo LED Verde
      ledcWrite(pwmChannelG, 255);
      ledcWrite(pwmChannelR, 0);
      ledcWrite(pwmChannelB, 0);
      break;
    case 3: // Posición 3 - solo LED Azul
      ledcWrite(pwmChannelB, 255);
      ledcWrite(pwmChannelG, 0);
      ledcWrite(pwmChannelR, 0);
      break;
    case 4: // Extremo derecho - todos apagados
    apagarLEDs();
      break;
  }
}

//******************************************/
// Setup
//******************************************/
void setup() {
  pinMode(butSelec, INPUT_PULLUP);
  pinMode(butBri, INPUT_PULLUP);
  pinMode(butDerecha, INPUT_PULLUP);
  pinMode(butIzquierda, INPUT_PULLUP);

  initPWM();

  attachInterrupt(digitalPinToInterrupt(butSelec), ISR_cambioModo, FALLING);
  attachInterrupt(digitalPinToInterrupt(butBri), ISR_cambioBrillo, FALLING);
  attachInterrupt(digitalPinToInterrupt(butDerecha), ISR_Derecha, FALLING);
  attachInterrupt(digitalPinToInterrupt(butIzquierda), ISR_Izquierda, FALLING);
}

//******************************************/
// Loop principal
//******************************************/
void loop() {
  // Cambio de modo
  if (flagSelec) {
    flagSelec = false;
    uint8_t modoAnterior = modoActual;
    modoActual = (modoActual + 1) % 4;
    
    // Transición al modo servo
    if (modoActual == 3) {
      modoServoActivo = true;
      actualizarIndicacionServo(); // Mostrar posición actual
    } 
    // Transición desde modo servo a otro modo
    else if (modoAnterior == 3) {
      modoServoActivo = false;
      actualizarLEDs(); // Restaurar brillo de LEDs según configuración
    }
  }

  // Manejo de cada modo
  switch (modoActual) {
    case 0: // Modo LED Rojo
          // Ajuste de brillo para el LED seleccionado
      if (flagBri) {
        flagBri = false;
        nivelBrillo[modoActual] = (nivelBrillo[modoActual] + 1) % numBrillos;
        actualizarLEDs();
      }
      
      // Movimiento servo independiente
      if (moverDerecha) {
        moverDerecha = false;
        if (posicionActual < 4) posicionActual++;
      }
      if (moverIzquierda) {
        moverIzquierda = false;
        if (posicionActual > 0) posicionActual--;
      }
      break;
    case 1: // Modo LED Verde
          // Ajuste de brillo para el LED seleccionado
      if (flagBri) {
        flagBri = false;
        nivelBrillo[modoActual] = (nivelBrillo[modoActual] + 1) % numBrillos;
        actualizarLEDs();
      }
      
      // Movimiento servo independiente
      if (moverDerecha) {
        moverDerecha = false;
        if (posicionActual < 4) posicionActual++;
      }
      if (moverIzquierda) {
        moverIzquierda = false;
        if (posicionActual > 0) posicionActual--;
      }
      break;
    case 2: // Modo LED Azul
      // Ajuste de brillo para el LED seleccionado
      if (flagBri) {
        flagBri = false;
        nivelBrillo[modoActual] = (nivelBrillo[modoActual] + 1) % numBrillos;
        actualizarLEDs();
      }
      
      // Movimiento servo independiente
      if (moverDerecha) {
        moverDerecha = false;
        if (posicionActual < 4) posicionActual++;
      }
      if (moverIzquierda) {
        moverIzquierda = false;
        if (posicionActual > 0) posicionActual--;
      }
      break;
      
    case 3: // Modo Servo
      // Botón de brillo no realiza nada en este modo
      if (flagBri) {
        flagBri = false;
      }
      
      // Movimiento servo con indicación LED exacta
      if (moverDerecha) {
        moverDerecha = false;
        if (posicionActual < 4) {
          posicionActual++;
          actualizarIndicacionServo(); // Actualizar LEDs inmediatamente
        }
      }
      if (moverIzquierda) {
        moverIzquierda = false;
        if (posicionActual > 0) {
          posicionActual--;
          actualizarIndicacionServo(); // Actualizar LEDs inmediatamente
        }
      }
      break;
  }

  // Mover servo suavemente a la posición actual
  moverServoSuave(posiciones[posicionActual]);
}
